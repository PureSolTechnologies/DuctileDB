package com.puresoltechnologies.ductiledb.core.graph.tx;

import static com.puresoltechnologies.ductiledb.core.graph.schema.HBaseSchema.ID_ROW_BYTES;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NavigableMap;
import java.util.Set;
import java.util.function.Consumer;

import org.apache.hadoop.hbase.client.Connection;
import org.apache.hadoop.hbase.client.Get;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.client.ResultScanner;
import org.apache.hadoop.hbase.client.Scan;
import org.apache.hadoop.hbase.client.Table;
import org.apache.hadoop.hbase.util.Bytes;

import com.puresoltechnologies.ductiledb.api.DuctileDBException;
import com.puresoltechnologies.ductiledb.api.graph.DuctileDBEdge;
import com.puresoltechnologies.ductiledb.api.graph.DuctileDBVertex;
import com.puresoltechnologies.ductiledb.api.graph.EdgeDirection;
import com.puresoltechnologies.ductiledb.api.graph.NoSuchGraphElementException;
import com.puresoltechnologies.ductiledb.api.graph.tx.DuctileDBCommitException;
import com.puresoltechnologies.ductiledb.api.graph.tx.DuctileDBTransaction;
import com.puresoltechnologies.ductiledb.api.graph.tx.TransactionType;
import com.puresoltechnologies.ductiledb.core.blob.BlobStoreImpl;
import com.puresoltechnologies.ductiledb.core.graph.DuctileDBAttachedEdge;
import com.puresoltechnologies.ductiledb.core.graph.DuctileDBGraphImpl;
import com.puresoltechnologies.ductiledb.core.graph.schema.DuctileDBSchema;
import com.puresoltechnologies.ductiledb.core.graph.schema.HBaseColumn;
import com.puresoltechnologies.ductiledb.core.graph.schema.HBaseColumnFamily;
import com.puresoltechnologies.ductiledb.core.graph.schema.HBaseTable;
import com.puresoltechnologies.ductiledb.core.graph.utils.ElementUtils;
import com.puresoltechnologies.ductiledb.core.graph.utils.IdEncoder;
import com.puresoltechnologies.ductiledb.core.graph.utils.Serializer;

/**
 * This transaction is used per thread to record changes in the graph to be
 * committed as batch.
 * 
 * @author Rick-Rainer Ludwig
 */
public class DuctileDBTransactionImpl implements DuctileDBTransaction {

    /**
     * The number of ids which are generated by this transaction without asking
     * the database for a new id. The id on the database is increased by this
     * number, so that each client gets its own range of ids to avoid double id
     * assignment.
     */
    static final long ID_CACHE_SIZE = 100;

    private long vertexIdCounter = ID_CACHE_SIZE;
    private long edgeIdCounter = ID_CACHE_SIZE;
    private long nextVertexId = -1;
    private long nextEdgeId = -1;

    private final LinkedList<TxOperation> txOperations = new LinkedList<>();
    private final Map<Long, DuctileDBCacheVertex> vertexCache = new HashMap<>();
    private final Map<Long, DuctileDBCacheEdge> edgeCache = new HashMap<>();

    private final ThreadLocal<List<Consumer<Status>>> transactionListeners = ThreadLocal
	    .withInitial(() -> new ArrayList<>());

    private final BlobStoreImpl blobStore;
    private final DuctileDBGraphImpl graph;
    private final TransactionType type;
    private final long threadId;
    private final Connection connection;
    private boolean closed = false;

    public DuctileDBTransactionImpl(BlobStoreImpl blobStore, DuctileDBGraphImpl graph, TransactionType type) {
	this.blobStore = blobStore;
	this.graph = graph;
	this.connection = graph.getConnection();
	this.threadId = Thread.currentThread().getId();
	this.type = type;
    }

    public DuctileDBGraphImpl getGraph() {
	return graph;
    }

    @Override
    public TransactionType getTransactionType() {
	return type;
    }

    public final Connection getConnection() {
	return connection;
    }

    @Override
    public void commit() {
	checkForClosedAndCorrectThread();
	try {
	    for (DuctileDBVertex vertex : vertexCache.values()) {
		if (vertex != null) {
		    getSchema().checkVertex(vertex);
		}
	    }
	    for (DuctileDBEdge edge : edgeCache.values()) {
		if (edge != null) {
		    getSchema().checkEdge(edge);
		}
	    }
	    for (TxOperation operation : txOperations) {
		operation.perform();
	    }
	    fireOnCommit();
	} catch (IOException e) {
	    throw new DuctileDBCommitException(e);
	} finally {
	    clear();
	}
    }

    @Override
    public void rollback() {
	checkForClosedAndCorrectThread();
	try {
	    txOperations.descendingIterator().forEachRemaining(operation -> operation.rollbackInternally());
	    fireOnRollback();
	} finally {
	    clear();
	}
    }

    @Override
    public boolean isOpen() {
	return (!vertexCache.isEmpty()) || (!edgeCache.isEmpty()) || (!txOperations.isEmpty());
    }

    private void clear() {
	txOperations.clear();
	vertexCache.clear();
	edgeCache.clear();
    }

    private void checkForClosedAndCorrectThread() {
	if (closed) {
	    throw new IllegalStateException("Transaction was already closed.");
	}
	if (type == TransactionType.THREAD_LOCAL) {
	    long currentThreadId = Thread.currentThread().getId();
	    if (currentThreadId != threadId) {
		throw new IllegalStateException("Thread local transaction thread id " + threadId
			+ " is trying to be used with thread with id " + currentThreadId);
	    }
	}
    }

    @Override
    public void close() {
	rollback();
	closed = true;
    }

    void setCachedVertex(DuctileDBCacheVertex vertex) {
	vertexCache.put(vertex.getId(), vertex);
    }

    DuctileDBCacheVertex getCachedVertex(long vertexId) {
	if (wasVertexRemoved(vertexId)) {
	    return null;
	}
	DuctileDBCacheVertex vertex = vertexCache.get(vertexId);
	if (vertex != null) {
	    return vertex;
	}
	try (Table vertexTable = openVertexTable()) {
	    byte[] id = IdEncoder.encodeRowId(vertexId);
	    Get get = new Get(id);
	    Result result = vertexTable.get(get);
	    if (!result.isEmpty()) {
		vertex = ResultDecoder.toVertex(this, vertexId, result);
	    }
	    if (vertex != null) {
		setCachedVertex(vertex);
	    }
	    return vertex;
	} catch (IOException e) {
	    throw new DuctileDBException("Could not get vertex.", e);
	}
    }

    void removeCachedVertex(long vertexId) {
	vertexCache.put(vertexId, null);
    }

    boolean wasVertexRemoved(long vertexId) {
	return (vertexCache.containsKey(vertexId)) && (vertexCache.get(vertexId) == null);
    }

    void setCachedEdge(DuctileDBCacheEdge edge) {
	edgeCache.put(edge.getId(), edge);
    }

    DuctileDBCacheEdge getCachedEdge(long edgeId) {
	if (wasEdgeRemoved(edgeId)) {
	    return null;
	}
	DuctileDBCacheEdge edge = edgeCache.get(edgeId);
	if (edge != null) {
	    return edge;
	}
	try (Table table = openEdgeTable()) {
	    byte[] id = IdEncoder.encodeRowId(edgeId);
	    Get get = new Get(id);
	    Result result = table.get(get);
	    if (!result.isEmpty()) {
		edge = ResultDecoder.toCacheEdge(this, edgeId, result);
	    }
	    if (edge != null) {
		setCachedEdge(edge);
	    }
	    return edge;
	} catch (IOException e) {
	    throw new DuctileDBException("Could not get edge.", e);
	}
    }

    void removeCachedEdge(long edgeId) {
	edgeCache.put(edgeId, null);
    }

    boolean wasEdgeRemoved(long edgeId) {
	return (edgeCache.containsKey(edgeId)) && (edgeCache.get(edgeId) == null);
    }

    Table openMetaDataTable() throws IOException {
	return connection.getTable(HBaseTable.METADATA.getTableName());
    }

    Table openVertexTable() throws IOException {
	return connection.getTable(HBaseTable.VERTICES.getTableName());
    }

    Table openEdgeTable() throws IOException {
	return connection.getTable(HBaseTable.EDGES.getTableName());
    }

    Table openVertexPropertyTable() throws IOException {
	return connection.getTable(HBaseTable.VERTEX_PROPERTIES.getTableName());
    }

    Table openVertexTypesTable() throws IOException {
	return connection.getTable(HBaseTable.VERTEX_TYPES.getTableName());
    }

    Table openEdgePropertyTable() throws IOException {
	return connection.getTable(HBaseTable.EDGE_PROPERTIES.getTableName());
    }

    Table openEdgeTypesTable() throws IOException {
	return connection.getTable(HBaseTable.EDGE_TYPES.getTableName());
    }

    final long createVertexId() {
	if (vertexIdCounter >= ID_CACHE_SIZE) {
	    try (Table metaDataTable = openMetaDataTable()) {
		nextVertexId = metaDataTable.incrementColumnValue(ID_ROW_BYTES,
			HBaseColumnFamily.METADATA.getNameBytes(), HBaseColumn.VERTEX_ID.getNameBytes(), ID_CACHE_SIZE);
		vertexIdCounter = 0;
	    } catch (IOException e) {
		throw new DuctileDBException("Could not create vertex id.", e);
	    }
	}
	long id = nextVertexId;
	++nextVertexId;
	++vertexIdCounter;
	return id;
    }

    final long createEdgeId() {
	if (edgeIdCounter >= ID_CACHE_SIZE) {
	    try (Table metaDataTable = openMetaDataTable()) {
		nextEdgeId = metaDataTable.incrementColumnValue(ID_ROW_BYTES, HBaseColumnFamily.METADATA.getNameBytes(),
			HBaseColumn.EDGE_ID.getNameBytes(), ID_CACHE_SIZE);
		edgeIdCounter = 0;
	    } catch (IOException e) {
		throw new DuctileDBException("Could not create edge id.", e);
	    }
	}
	long id = nextEdgeId;
	++nextEdgeId;
	++edgeIdCounter;
	return id;
    }

    private DuctileDBSchema getSchema() {
	return graph.getSchema();
    }

    @Override
    public DuctileDBVertex addVertex(Set<String> types, Map<String, Object> properties) {
	checkForClosedAndCorrectThread();
	getSchema().checkAddVertex(types, properties);
	long vertexId = createVertexId();
	addTxOperation(new AddVertexOperation(this, vertexId, types, properties));
	return getVertex(vertexId);
    }

    @Override
    public DuctileDBVertex addBlobVertex(InputStream blobContent, Set<String> types, Map<String, Object> properties) {
	checkForClosedAndCorrectThread();
	getSchema().checkAddVertex(types, properties);
	long vertexId = createVertexId();
	addTxOperation(new AddBlobVertexOperation(this, vertexId, blobContent, types, properties));
	return getVertex(vertexId);
    }

    @Override
    public DuctileDBEdge addEdge(DuctileDBVertex startVertex, DuctileDBVertex targetVertex, String type,
	    Map<String, Object> properties) {
	checkForClosedAndCorrectThread();
	getSchema().checkAddEdge(type, properties);
	long edgeId = createEdgeId();
	addTxOperation(new AddEdgeOperation(this, edgeId, startVertex.getId(), targetVertex.getId(), type, properties));
	return getEdge(edgeId);
    }

    @Override
    public DuctileDBEdge getEdge(long edgeId) {
	DuctileDBEdge edge = getCachedEdge(edgeId);
	if (edge == null) {
	    throw new NoSuchGraphElementException("Edge with id " + edgeId + " is not available.");
	}
	return ElementUtils.toAttached(edge);
    }

    @Override
    public Iterable<DuctileDBEdge> getEdges() {
	try (Table table = openEdgeTable()) {
	    ResultScanner result = table.getScanner(new Scan());
	    return new AttachedEdgeIterable(this, result);
	} catch (IOException e) {
	    throw new DuctileDBException("Could not get edge.", e);
	}
    }

    @Override
    public Iterable<DuctileDBEdge> getEdges(String propertyKey, Object propertyValue) {
	if ((propertyKey == null) || (propertyKey.isEmpty())) {
	    throw new IllegalArgumentException("Property key must not be null.");
	}
	try (Table table = openEdgePropertyTable()) {
	    List<DuctileDBEdge> edges = new ArrayList<>();
	    Result result = table.get(new Get(Bytes.toBytes(propertyKey)));
	    NavigableMap<byte[], byte[]> map = result.getFamilyMap(HBaseColumnFamily.INDEX.getNameBytes());
	    if (map != null) {
		for (Entry<byte[], byte[]> entry : map.entrySet()) {
		    Object value = Serializer.deserializePropertyValue(entry.getValue());
		    if ((propertyValue == null) || (value.equals(propertyValue))) {
			long edgeId = IdEncoder.decodeRowId(entry.getKey());
			if (!wasEdgeRemoved(edgeId)) {
			    DuctileDBEdge edge = getEdge(edgeId);
			    if ((edge != null) && //
				    ((propertyValue == null)
					    || (propertyValue.equals(edge.getProperty(propertyKey))))) {
				edges.add(edge);
			    }
			}
		    }
		}
	    }

	    for (DuctileDBCacheEdge edge : addedEdges()) {
		long edgeId = edge.getId();
		Object value = edge.getProperty(propertyKey);
		if ((value == null) || (value.equals(propertyValue))) {
		    if (!wasEdgeRemoved(edgeId)) {
			if ((propertyValue == null) || (propertyValue.equals(edge.getProperty(propertyKey)))) {
			    edges.add(edge);
			}
		    }
		}
	    }

	    return new Iterable<DuctileDBEdge>() {
		@Override
		public Iterator<DuctileDBEdge> iterator() {
		    return edges.iterator();
		}
	    };
	} catch (IOException e) {
	    throw new DuctileDBException("Could not get edges.", e);
	}
    }

    @Override
    public Iterable<DuctileDBEdge> getEdges(String type) {
	if ((type == null) || (type.isEmpty())) {
	    throw new IllegalArgumentException("Type must not be null.");
	}
	try (Table table = openEdgeTypesTable()) {
	    Result result = table.get(new Get(Bytes.toBytes(type)));
	    NavigableMap<byte[], byte[]> map = result.getFamilyMap(HBaseColumnFamily.INDEX.getNameBytes());
	    List<DuctileDBEdge> edges = new ArrayList<>();
	    for (byte[] edgeIdBytes : map.keySet()) {
		long edgeId = IdEncoder.decodeRowId(edgeIdBytes);
		if (!wasEdgeRemoved(edgeId)) {
		    DuctileDBEdge edge = getEdge(edgeId);
		    if ((edge != null) && (type.equals(edge.getType()))) {
			edges.add(edge);
		    }
		}
	    }

	    for (DuctileDBCacheEdge edge : addedEdges()) {
		long edgeId = edge.getId();
		if (!wasEdgeRemoved(edgeId)) {
		    if (type.equals(edge.getType())) {
			edges.add(edge);
		    }
		}
	    }

	    return new Iterable<DuctileDBEdge>() {
		@Override
		public Iterator<DuctileDBEdge> iterator() {
		    return edges.iterator();
		}
	    };
	} catch (IOException e) {
	    throw new DuctileDBException("Could not get edges.", e);
	}
    }

    @Override
    public DuctileDBVertex getVertex(long vertexId) {
	DuctileDBVertex vertex = getCachedVertex(vertexId);
	if (vertex == null) {
	    throw new NoSuchGraphElementException("Vertex with id " + vertexId + " is not available.");
	}
	return ElementUtils.toAttached(vertex);
    }

    @Override
    public Iterable<DuctileDBVertex> getVertices() {
	try (Table table = openVertexTable()) {
	    ResultScanner result = table.getScanner(new Scan());
	    return new AttachedVertexIterable(this, result);
	} catch (IOException e) {
	    throw new DuctileDBException("Could not get vertices.", e);
	}
    }

    @Override
    public Iterable<DuctileDBVertex> getVertices(String propertyKey, Object propertyValue) {
	if ((propertyKey == null) || (propertyKey.isEmpty())) {
	    throw new IllegalArgumentException("Property key must not be null.");
	}
	try (Table table = openVertexPropertyTable()) {
	    List<DuctileDBVertex> vertices = new ArrayList<>();
	    Get get = new Get(Bytes.toBytes(propertyKey));
	    get.addFamily(HBaseColumnFamily.INDEX.getNameBytes());
	    Result result = table.get(get);
	    NavigableMap<byte[], byte[]> propertyMap = result.getFamilyMap(HBaseColumnFamily.INDEX.getNameBytes());
	    if (propertyMap != null) {
		for (Entry<byte[], byte[]> entry : propertyMap.entrySet()) {
		    Object value = Serializer.deserializePropertyValue(entry.getValue());
		    if ((propertyValue == null) || (propertyValue.equals(value))) {
			long vertexId = IdEncoder.decodeRowId(entry.getKey());
			if (!wasVertexRemoved(vertexId)) {
			    DuctileDBVertex vertex = getVertex(vertexId);
			    if ((vertex != null) && //
				    ((propertyValue == null)
					    || (vertex.getProperty(propertyKey).equals(propertyValue)))) {
				vertices.add(vertex);
			    }
			}
		    }
		}
	    }

	    for (DuctileDBCacheVertex vertex : addedVertices()) {
		Object value = vertex.getProperty(propertyKey);
		if ((propertyValue == null) || (propertyValue.equals(value))) {
		    if (!wasVertexRemoved(vertex.getId())) {
			if ((propertyValue == null) || (vertex.getProperty(propertyKey).equals(propertyValue))) {
			    vertices.add(vertex);
			}
		    }
		}
	    }

	    return new Iterable<DuctileDBVertex>() {
		@Override
		public Iterator<DuctileDBVertex> iterator() {
		    return vertices.iterator();
		}
	    };
	} catch (IOException e) {
	    throw new DuctileDBException("Could not get vertices.", e);
	}
    }

    @Override
    public Iterable<DuctileDBVertex> getVertices(String type) {
	if ((type == null) || (type.isEmpty())) {
	    throw new IllegalArgumentException("Type must not be null.");
	}
	try (Table table = openVertexTypesTable()) {
	    List<DuctileDBVertex> vertices = new ArrayList<>();
	    Get get = new Get(Bytes.toBytes(type));
	    get.addFamily(HBaseColumnFamily.INDEX.getNameBytes());
	    Result result = table.get(get);
	    NavigableMap<byte[], byte[]> propertyMap = result.getFamilyMap(HBaseColumnFamily.INDEX.getNameBytes());
	    if (propertyMap != null) {
		for (byte[] vertexIdBytes : propertyMap.keySet()) {
		    long vertexId = IdEncoder.decodeRowId(vertexIdBytes);
		    if (!wasVertexRemoved(vertexId)) {
			DuctileDBVertex vertex = getVertex(vertexId);
			if ((vertex != null) && (ElementUtils.getTypes(vertex).contains(type))) {
			    vertices.add(vertex);
			}
		    }
		}
	    }

	    for (DuctileDBCacheVertex vertex : addedVertices()) {
		long vertexId = vertex.getId();
		if (!wasVertexRemoved(vertexId)) {
		    if (ElementUtils.getTypes(vertex).contains(type)) {
			vertices.add(vertex);
		    }
		}
	    }

	    return new Iterable<DuctileDBVertex>() {
		@Override
		public Iterator<DuctileDBVertex> iterator() {
		    return vertices.iterator();
		}
	    };
	} catch (IOException e) {
	    throw new DuctileDBException("Could not get vertices.", e);
	}
    }

    @Override
    public void removeEdge(DuctileDBEdge edge) {
	checkForClosedAndCorrectThread();
	if (wasEdgeRemoved(edge.getId())) {
	    return;
	}
	addTxOperation(new RemoveEdgeOperation(this, edge));
    }

    @Override
    public void removeVertex(DuctileDBVertex vertex) {
	checkForClosedAndCorrectThread();
	if (wasVertexRemoved(vertex.getId())) {
	    return;
	}
	long vertexId = vertex.getId();
	for (DuctileDBEdge edge : vertex.getEdges(EdgeDirection.BOTH)) {
	    removeEdge(edge);
	}
	for (String type : ElementUtils.getTypes(vertex)) {
	    removeType(vertex, type);
	}
	for (String key : new HashSet<>(vertex.getPropertyKeys())) {
	    removeProperty(vertex, key);
	}
	addTxOperation(new RemoveVertexOperation(this, vertexId));
    }

    public void addType(DuctileDBVertex vertex, String type) {
	checkForClosedAndCorrectThread();
	getSchema().checkAddVertexType(vertex, type);
	addTxOperation(new AddVertexTypeOperation(this, vertex.getId(), type));
    }

    public void removeType(DuctileDBVertex vertex, String type) {
	checkForClosedAndCorrectThread();
	addTxOperation(new RemoveVertexTypeOperation(this, vertex, type));
    }

    public void setProperty(DuctileDBVertex vertex, String key, Object value) {
	checkForClosedAndCorrectThread();
	getSchema().checkSetVertexProperty(vertex, key, value);
	addTxOperation(new SetVertexPropertyOperation(this, vertex, key, value));
    }

    public void removeProperty(DuctileDBVertex vertex, String key) {
	checkForClosedAndCorrectThread();
	getSchema().checkRemoveVertexProperty(vertex, key);
	addTxOperation(new RemoveVertexPropertyOperation(this, vertex, key));
    }

    public void setProperty(DuctileDBEdge edge, String key, Object value) {
	checkForClosedAndCorrectThread();
	getSchema().checkSetEdgeProperty(edge, key, value);
	addTxOperation(new SetEdgePropertyOperation(this, edge, key, value));
    }

    public void removeProperty(DuctileDBEdge edge, String key) {
	checkForClosedAndCorrectThread();
	getSchema().checkRemoveEdgeProperty(edge, key);
	addTxOperation(new RemoveEdgePropertyOperation(this, edge, key));
    }

    private void addTxOperation(TxOperation operation) {
	operation.commitInternally();
	txOperations.add(operation);
    }

    public List<DuctileDBCacheVertex> addedVertices() {
	List<DuctileDBCacheVertex> vertices = new ArrayList<>();
	for (TxOperation operation : txOperations) {
	    if (AddVertexOperation.class.isAssignableFrom(operation.getClass())) {
		AddVertexOperation addOperation = (AddVertexOperation) operation;
		vertices.add(getCachedVertex(addOperation.getVertexId()));
	    }
	}
	return vertices;
    }

    public List<DuctileDBCacheEdge> addedEdges() {
	List<DuctileDBCacheEdge> edges = new ArrayList<>();
	for (TxOperation operation : txOperations) {
	    if (AddEdgeOperation.class.isAssignableFrom(operation.getClass())) {
		AddEdgeOperation addOperation = (AddEdgeOperation) operation;
		edges.add(getCachedEdge(addOperation.getEdgeId()));
	    }
	}
	return edges;
    }

    private void fireOnCommit() {
	transactionListeners.get().forEach(c -> c.accept(Status.COMMIT));
    }

    private void fireOnRollback() {
	transactionListeners.get().forEach(c -> c.accept(Status.ROLLBACK));
    }

    @Override
    public void addTransactionListener(Consumer<Status> listener) {
	transactionListeners.get().add(listener);
    }

    @Override
    public void removeTransactionListener(final Consumer<Status> listener) {
	transactionListeners.get().remove(listener);
    }

    @Override
    public void clearTransactionListeners() {
	transactionListeners.get().clear();
    }

    public List<DuctileDBEdge> getEdges(long vertexId, EdgeDirection direction, String[] edgeTypes) {
	DuctileDBCacheVertex cachedVertex = getCachedVertex(vertexId);
	List<DuctileDBEdge> edges = new ArrayList<>();
	List<String> typeList = Arrays.asList(edgeTypes);
	for (DuctileDBEdge cachedEdge : cachedVertex.getEdges(direction, edgeTypes)) {
	    if ((edgeTypes.length == 0) || (typeList.contains(cachedEdge.getType()))) {
		DuctileDBAttachedEdge edge = ElementUtils.toAttached(cachedEdge);
		switch (direction) {
		case IN:
		    if (edge.getTargetVertex().getId() == vertexId) {
			edges.add(ElementUtils.toAttached(edge));
		    }
		    break;
		case OUT:
		    if (edge.getStartVertex().getId() == vertexId) {
			edges.add(ElementUtils.toAttached(edge));
		    }
		    break;
		case BOTH:
		    edges.add(ElementUtils.toAttached(edge));
		    break;
		default:
		    throw new IllegalArgumentException("Direction '" + direction + "' is not supported.");
		}
	    }
	}
	return edges;
    }

    public Iterable<DuctileDBEdge> getVertexEdges(long vertexId) {
	Iterable<DuctileDBEdge> cachedEdges = getCachedVertex(vertexId).getEdges(EdgeDirection.BOTH);
	List<DuctileDBEdge> edges = new ArrayList<>();
	for (DuctileDBEdge edge : cachedEdges) {
	    if (!wasEdgeRemoved(edge.getId())) {
		edges.add(edge);
	    }
	}
	return edges;
    }

    public Iterable<String> getVertexTypes(long vertexId) {
	DuctileDBCacheVertex cachedVertex = getCachedVertex(vertexId);
	return cachedVertex.getTypes();
    }

    public boolean hasType(long vertexId, String type) {
	DuctileDBCacheVertex cachedVertex = getCachedVertex(vertexId);
	return cachedVertex.hasType(type);
    }

    public Set<String> getVertexPropertyKeys(long vertexId) {
	DuctileDBCacheVertex cachedVertex = getCachedVertex(vertexId);
	return cachedVertex.getPropertyKeys();
    }

    public <T> T getVertexProperty(long vertexId, String key) {
	DuctileDBCacheVertex cachedVertex = getCachedVertex(vertexId);
	return cachedVertex.getProperty(key);
    }

    public DuctileDBVertex getEdgeStartVertex(long edgeId) {
	DuctileDBCacheEdge cachedEdge = getCachedEdge(edgeId);
	return getVertex(cachedEdge.getStartVertexId());
    }

    public DuctileDBVertex getEdgeTargetVertex(long edgeId) {
	DuctileDBCacheEdge cachedEdge = getCachedEdge(edgeId);
	return getVertex(cachedEdge.getTargetVertexId());
    }

    public String getEdgeType(long edgeId) {
	DuctileDBCacheEdge cachedEdge = getCachedEdge(edgeId);
	return cachedEdge.getType();
    }

    public Set<String> getEdgePropertyKeys(long edgeId) {
	DuctileDBCacheEdge cachedEdge = getCachedEdge(edgeId);
	return cachedEdge.getPropertyKeys();
    }

    public <T> T getEdgeProperty(long edgeId, String key) {
	DuctileDBCacheEdge cachedEdge = getCachedEdge(edgeId);
	return cachedEdge.getProperty(key);
    }

    @Override
    public String toString() {
	return "transaction: type=" + type.name() + "; closed=" + closed;
    }

    public BlobStoreImpl getBlobStore() {
	return blobStore;
    }

}
